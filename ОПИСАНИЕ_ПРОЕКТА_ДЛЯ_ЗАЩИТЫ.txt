================================================================================
                    ОПИСАНИЕ ПРОЕКТА CarShareX
                     (Каршеринг-приложение)
                 Учебный проект для защиты курсовой/диплома
================================================================================

ОГЛАВЛЕНИЕ:
1. Общая информация о проекте
2. Стек технологий и его преимущества
3. Архитектура приложения
4. База данных: таблицы и связи
5. Реализация в приложении
6. API endpoints
7. Заключение

================================================================================
1. ОБЩАЯ ИНФОРМАЦИЯ О ПРОЕКТЕ
================================================================================

CarShareX - это полнофункциональное веб-приложение для каршеринга (аренды
автомобилей), разработанное в качестве учебного проекта. Приложение позволяет
пользователям арендовать автомобили, управлять бронированиями, пополнять
баланс, а администраторам - управлять всем автопарком, сотрудниками и
отслеживать статистику.

ОСНОВНЫЕ ВОЗМОЖНОСТИ:
- Регистрация и авторизация пользователей (клиенты и сотрудники)
- Просмотр каталога доступных автомобилей с фильтрацией
- Бронирование автомобилей на определенное время
- Управление балансом и транзакциями
- Система тарификации
- Администраторская панель для управления системой
- Отчеты об инцидентах
- Управление парковочными зонами и филиалами

ЦЕЛЕВАЯ АУДИТОРИЯ:
- Клиенты: обычные пользователи, желающие арендовать автомобиль
- Администраторы: сотрудники компании для управления системой
- Менеджеры: руководители для просмотра статистики

================================================================================
2. СТЕК ТЕХНОЛОГИЙ И ЕГО ПРЕИМУЩЕСТВА
================================================================================

Проект реализован с использованием современного и популярного стека технологий,
который обеспечивает высокую производительность, масштабируемость и удобство
разработки.

----- BACKEND (Серверная часть) -----

1. Python 3.12
   - Современный, популярный язык программирования
   - Простой синтаксис, быстрая разработка
   - Огромная экосистема библиотек

2. FastAPI 0.115.0
   ПОЧЕМУ FASTAPI КРУТОЙ:
   - Один из самых быстрых Python-фреймворков (производительность как у Go/Node.js)
   - Автоматическая генерация документации API (Swagger UI)
   - Встроенная валидация данных через Pydantic
   - Поддержка асинхронности из коробки
   - Типизация кода (type hints) для меньшего количества ошибок
   - Современный подход к разработке REST API
   - Используется такими компаниями как Microsoft, Netflix, Uber

3. SQLAlchemy 2.0.35
   ПРЕИМУЩЕСТВА:
   - ORM (Object-Relational Mapping) - работа с БД как с объектами Python
   - Поддержка множества СУБД (SQLite, PostgreSQL, MySQL)
   - Защита от SQL-инъекций
   - Удобная работа со связями между таблицами
   - Миграции схемы БД

4. PostgreSQL (Production) / SQLite (Development)
   - PostgreSQL - мощная реляционная СУБД
   - SQLite - легковесная БД для разработки
   - Поддержка транзакций, индексов, внешних ключей

5. Uvicorn 0.31.0
   - Высокопроизводительный ASGI сервер
   - Поддержка асинхронного кода
   - Быстрая обработка запросов

6. Pydantic 2.9.2
   - Валидация данных на основе типов Python
   - Автоматическое преобразование типов
   - Детальные сообщения об ошибках валидации

----- FRONTEND (Клиентская часть) -----

1. React 18.2.0
   ПОЧЕМУ REACT:
   - Самая популярная библиотека для создания UI (используют Facebook, Instagram)
   - Компонентный подход - переиспользование кода
   - Virtual DOM для быстрого рендеринга
   - Огромное сообщество и экосистема библиотек

2. TypeScript 5.2.2
   ПРЕИМУЩЕСТВА:
   - Строгая типизация = меньше ошибок на production
   - Автодополнение в IDE
   - Легче поддерживать большие проекты
   - Рефакторинг становится безопаснее

3. Redux Toolkit 1.9.7
   - Централизованное управление состоянием приложения
   - Предсказуемое изменение данных
   - Удобная отладка через DevTools

4. React Router 6.20.0
   - Маршрутизация на клиенте (SPA)
   - Быстрая навигация без перезагрузки страницы

5. TailwindCSS 3.3.5
   ПОЧЕМУ TAILWIND:
   - Utility-first подход - быстрая разработка UI
   - Малый размер финального CSS (удаление неиспользуемых классов)
   - Консистентный дизайн из коробки
   - Адаптивность (responsive design) очень легко

6. Vite 5.0.0
   - Сверхбыстрая сборка проекта
   - Hot Module Replacement (HMR) - мгновенное обновление при разработке
   - Оптимизация production сборки

7. Дополнительные библиотеки:
   - Axios - HTTP клиент для API запросов
   - React Hook Form - управление формами
   - Zod - схемы валидации
   - Framer Motion - анимации
   - React Hot Toast - уведомления

----- ПОЧЕМУ ЭТОТ СТЕК КРУТОЙ (РЕЗЮМЕ) -----

1. ПРОИЗВОДИТЕЛЬНОСТЬ:
   - FastAPI - один из самых быстрых Python фреймворков
   - React с Virtual DOM - оптимизированный рендеринг
   - Vite - молниеносная сборка

2. СОВРЕМЕННОСТЬ:
   - Все технологии актуальны в 2024-2025 году
   - Активная поддержка и развитие
   - Используются в крупных компаниях

3. ТИПИЗАЦИЯ:
   - Python type hints + Pydantic
   - TypeScript на фронтенде
   - Меньше ошибок, легче поддержка

4. DEVELOPER EXPERIENCE (DX):
   - Автогенерация документации API
   - Hot reload при разработке
   - Отличные инструменты отладки

5. МАСШТАБИРУЕМОСТЬ:
   - Легко добавлять новые фичи
   - Компонентная архитектура
   - Разделение на микросервисы возможно в будущем

6. ВОСТРЕБОВАННОСТЬ НА РЫНКЕ:
   - React + TypeScript - самый популярный стек для фронтенда
   - Python + FastAPI - растущий тренд для бэкенда
   - Знание этих технологий = хорошие перспективы трудоустройства

================================================================================
3. АРХИТЕКТУРА ПРИЛОЖЕНИЯ
================================================================================

Приложение построено по классической клиент-серверной архитектуре с разделением
на frontend и backend.

----- СТРУКТУРА ПРОЕКТА -----

CarShareX/
├── back/                        # Backend (Python + FastAPI)
│   ├── db/                      # Работа с базой данных
│   │   ├── database.py          # Подключение к БД
│   │   ├── models.py            # ORM модели (таблицы)
│   │   └── init_data.py         # Начальные данные
│   ├── routers/                 # API endpoints (маршруты)
│   │   ├── auth.py              # Авторизация клиентов
│   │   ├── profile.py           # Профиль пользователя
│   │   ├── vehicles.py          # Автомобили (клиент)
│   │   ├── bookings.py          # Бронирования (клиент)
│   │   ├── transactions.py      # Транзакции
│   │   ├── employee_auth.py     # Авторизация сотрудников
│   │   └── admin_*.py           # Админские эндпоинты
│   ├── schemas/                 # Pydantic схемы (валидация)
│   │   ├── user.py
│   │   ├── vehicle.py
│   │   ├── booking.py
│   │   └── ...
│   ├── static/                  # Статические файлы (изображения)
│   ├── main.py                  # Точка входа приложения
│   └── requirements.txt         # Зависимости Python
│
└── front/                       # Frontend (React + TypeScript)
    ├── src/
    │   ├── components/          # React компоненты
    │   ├── pages/               # Страницы приложения
    │   ├── store/               # Redux store (состояние)
    │   ├── services/            # API сервисы (axios)
    │   ├── types/               # TypeScript типы
    │   └── App.tsx              # Главный компонент
    ├── public/                  # Публичные файлы
    └── package.json             # Зависимости JavaScript

----- ПРИНЦИПЫ АРХИТЕКТУРЫ -----

1. SEPARATION OF CONCERNS (Разделение ответственности):
   - Backend отвечает за бизнес-логику и данные
   - Frontend отвечает за UI и взаимодействие с пользователем
   - База данных отвечает за хранение

2. REST API:
   - Взаимодействие через HTTP запросы
   - JSON формат данных
   - Стандартные методы: GET, POST, PUT, DELETE

3. LAYERED ARCHITECTURE (Слоёная архитектура):
   Слой 1: Presentation Layer (Frontend - React)
            ↓ HTTP requests
   Слой 2: API Layer (FastAPI routers)
            ↓ вызовы функций
   Слой 3: Business Logic Layer (Pydantic schemas, валидация)
            ↓ ORM запросы
   Слой 4: Data Access Layer (SQLAlchemy ORM)
            ↓ SQL запросы
   Слой 5: Database Layer (PostgreSQL/SQLite)

4. MVC PATTERN (частично):
   - Model: SQLAlchemy модели (db/models.py)
   - View: React компоненты
   - Controller: FastAPI routers

----- ПОТОК ДАННЫХ (ПРИМЕР: БРОНИРОВАНИЕ АВТО) -----

1. Пользователь нажимает "Забронировать" на фронтенде
2. React вызывает функцию из API service
3. Axios отправляет POST запрос на backend /bookings
4. FastAPI роутер (routers/bookings.py) получает запрос
5. Pydantic схема валидирует данные (schemas/booking.py)
6. Бизнес-логика проверяет доступность авто
7. SQLAlchemy создает запись в БД через ORM
8. PostgreSQL сохраняет данные
9. Backend возвращает JSON ответ
10. Frontend обновляет UI и показывает уведомление

================================================================================
4. БАЗА ДАННЫХ: ТАБЛИЦЫ И СВЯЗИ
================================================================================

База данных спроектирована по принципам нормализации (3NF) с использованием
внешних ключей для обеспечения целостности данных.

----- СПИСОК ТАБЛИЦ -----

1. users - Клиенты каршеринга
2. employees - Сотрудники компании
3. roles - Роли сотрудников
4. branches - Филиалы компании
5. vehicles - Автомобили
6. tariffs - Тарифы
7. parking_zones - Парковочные зоны
8. bookings - Бронирования
9. transactions - Финансовые транзакции
10. incidents - Инциденты (ДТП, повреждения)

----- ПОДРОБНОЕ ОПИСАНИЕ ТАБЛИЦ -----

╔══════════════════════════════════════════════════════════════════════════╗
║ 1. ТАБЛИЦА: users (Пользователи-клиенты)                               ║
╚══════════════════════════════════════════════════════════════════════════╝

Хранит информацию о клиентах каршеринга.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ first_name         │ String(50)       │ Имя                             │
│ last_name          │ String(50)       │ Фамилия                         │
│ email              │ String(100)      │ Email (уникальный, индекс)      │
│ phone              │ String(20)       │ Телефон (уникальный, индекс)    │
│ password           │ String(100)      │ Пароль                          │
│ drivers_license    │ String(20)       │ Водительские права (уникальный) │
│ balance            │ Float            │ Баланс (по умолчанию 0.0)       │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- ONE-TO-MANY с bookings (один пользователь - много бронирований)
- ONE-TO-MANY с transactions (один пользователь - много транзакций)
- ONE-TO-MANY с incidents (один пользователь - много инцидентов)

Индексы:
- PRIMARY KEY на id
- UNIQUE INDEX на email
- UNIQUE INDEX на phone
- UNIQUE INDEX на drivers_license

╔══════════════════════════════════════════════════════════════════════════╗
║ 2. ТАБЛИЦА: roles (Роли сотрудников)                                   ║
╚══════════════════════════════════════════════════════════════════════════╝

Справочник ролей для сотрудников (админ, менеджер, техник).

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ name               │ String(50)       │ Название роли (уникальный)      │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- ONE-TO-MANY с employees (одна роль - много сотрудников)

Примеры данных:
- Администратор
- Менеджер
- Техник

╔══════════════════════════════════════════════════════════════════════════╗
║ 3. ТАБЛИЦА: branches (Филиалы компании)                                ║
╚══════════════════════════════════════════════════════════════════════════╝

Информация о филиалах компании каршеринга.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ name               │ String(100)      │ Название филиала (индекс)       │
│ address            │ String(255)      │ Адрес                           │
│ phone              │ String(20)       │ Телефон                         │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- ONE-TO-MANY с employees (один филиал - много сотрудников)

╔══════════════════════════════════════════════════════════════════════════╗
║ 4. ТАБЛИЦА: employees (Сотрудники)                                     ║
╚══════════════════════════════════════════════════════════════════════════╝

Сотрудники компании с доступом к админ-панели.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ first_name         │ String(50)       │ Имя                             │
│ last_name          │ String(50)       │ Фамилия                         │
│ email              │ String(100)      │ Email (уникальный, индекс)      │
│ password           │ String(100)      │ Пароль                          │
│ role_id            │ Integer          │ FK -> roles.id (индекс)         │
│ branch_id          │ Integer          │ FK -> branches.id (индекс)      │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- MANY-TO-ONE с roles (много сотрудников - одна роль)
- MANY-TO-ONE с branches (много сотрудников - один филиал)

Индексы:
- INDEX на role_id
- INDEX на branch_id

ТИП СВЯЗИ: MANY-TO-ONE (N:1)
Реализация: Внешний ключ role_id ссылается на roles.id
            Внешний ключ branch_id ссылается на branches.id

╔══════════════════════════════════════════════════════════════════════════╗
║ 5. ТАБЛИЦА: tariffs (Тарифы)                                           ║
╚══════════════════════════════════════════════════════════════════════════╝

Тарифные планы для аренды автомобилей.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ name               │ String(50)       │ Название тарифа (индекс)        │
│ price_per_minute   │ Float            │ Цена за минуту                  │
│ price_per_hour     │ Float            │ Цена за час                     │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- ONE-TO-MANY с vehicles (один тариф - много автомобилей)

Примеры данных:
- Эконом: 5₽/мин, 250₽/час
- Комфорт: 8₽/мин, 400₽/час
- Премиум: 12₽/мин, 600₽/час

╔══════════════════════════════════════════════════════════════════════════╗
║ 6. ТАБЛИЦА: parking_zones (Парковочные зоны)                           ║
╚══════════════════════════════════════════════════════════════════════════╝

Парковки, где размещены автомобили.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ name               │ String(100)      │ Название зоны (индекс)          │
│ address            │ String(255)      │ Адрес                           │
│ capacity           │ Integer          │ Вместимость (по умолчанию 10)   │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- ONE-TO-MANY с vehicles (одна зона - много автомобилей)

╔══════════════════════════════════════════════════════════════════════════╗
║ 7. ТАБЛИЦА: vehicles (Автомобили)                                      ║
╚══════════════════════════════════════════════════════════════════════════╝

Автопарк каршеринга.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ license_plate      │ String(20)       │ Номер авто (уникальный, индекс) │
│ brand              │ String(50)       │ Марка (индекс)                  │
│ model              │ String(50)       │ Модель                          │
│ vehicle_type       │ String(30)       │ Тип авто (индекс)               │
│ year               │ Integer          │ Год выпуска                     │
│ color              │ String(30)       │ Цвет                            │
│ image_url          │ String(500)      │ URL картинки                    │
│ description        │ String(500)      │ Описание                        │
│ status             │ String(30)       │ Статус (индекс, default='available') │
│ parking_zone_id    │ Integer          │ FK -> parking_zones.id (индекс) │
│ tariff_id          │ Integer          │ FK -> tariffs.id (индекс)       │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- MANY-TO-ONE с parking_zones (много авто - одна парковка)
- MANY-TO-ONE с tariffs (много авто - один тариф)
- ONE-TO-MANY с bookings (одно авто - много бронирований)
- ONE-TO-MANY с incidents (одно авто - много инцидентов)

Составные индексы:
- INDEX(status, vehicle_type) - для быстрой фильтрации
- INDEX(brand, model) - для поиска по марке/модели

ТИП СВЯЗИ: MANY-TO-ONE (N:1) с parking_zones и tariffs
Реализация: Внешние ключи parking_zone_id и tariff_id

Статусы авто:
- available - доступен
- in_use - используется
- maintenance - на обслуживании
- unavailable - недоступен

╔══════════════════════════════════════════════════════════════════════════╗
║ 8. ТАБЛИЦА: bookings (Бронирования)                                    ║
╚══════════════════════════════════════════════════════════════════════════╝

Бронирования автомобилей пользователями.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ user_id            │ Integer          │ FK -> users.id (индекс)         │
│ vehicle_id         │ Integer          │ FK -> vehicles.id (индекс)      │
│ tariff_id          │ Integer          │ FK -> tariffs.id (индекс)       │
│ start_time         │ DateTime         │ Время начала (индекс)           │
│ end_time           │ DateTime         │ Время окончания                 │
│ duration_hours     │ Float            │ Длительность в часах            │
│ total_cost         │ Float            │ Общая стоимость                 │
│ status             │ String(30)       │ Статус (индекс, default='pending') │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- MANY-TO-ONE с users (много бронирований - один пользователь)
- MANY-TO-ONE с vehicles (много бронирований - одно авто)
- MANY-TO-ONE с tariffs (много бронирований - один тариф)
- ONE-TO-MANY с transactions (одно бронирование - несколько транзакций)
- ONE-TO-MANY с incidents (одно бронирование - несколько инцидентов)

Составные индексы:
- INDEX(user_id, status) - для поиска бронирований пользователя по статусу
- INDEX(vehicle_id, status) - для поиска бронирований авто

ТИП СВЯЗИ: MANY-TO-ONE (N:1)
Реализация: Три внешних ключа - user_id, vehicle_id, tariff_id

Статусы бронирования:
- pending - ожидает начала
- active - активное
- completed - завершено
- cancelled - отменено

ВАЖНО: Это центральная таблица, связывающая пользователей и автомобили!

╔══════════════════════════════════════════════════════════════════════════╗
║ 9. ТАБЛИЦА: transactions (Транзакции)                                  ║
╚══════════════════════════════════════════════════════════════════════════╝

Финансовые операции пользователей.

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ user_id            │ Integer          │ FK -> users.id (индекс)         │
│ booking_id         │ Integer          │ FK -> bookings.id (индекс)      │
│ transaction_type   │ String(30)       │ Тип транзакции (индекс)         │
│ amount             │ Float            │ Сумма                           │
│ description        │ String(500)      │ Описание                        │
│ created_at         │ DateTime         │ Дата создания                   │
│ status             │ String(30)       │ Статус (индекс, default='completed') │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- MANY-TO-ONE с users (много транзакций - один пользователь)
- MANY-TO-ONE с bookings (несколько транзакций - одно бронирование)

Составной индекс:
- INDEX(user_id, transaction_type) - для фильтрации транзакций по типу

ТИП СВЯЗИ: MANY-TO-ONE (N:1)
Реализация: Внешние ключи user_id и booking_id (опциональный)

Типы транзакций:
- deposit - пополнение баланса
- payment - оплата поездки
- refund - возврат средств
- penalty - штраф

╔══════════════════════════════════════════════════════════════════════════╗
║ 10. ТАБЛИЦА: incidents (Инциденты)                                     ║
╚══════════════════════════════════════════════════════════════════════════╝

Отчеты о происшествиях (ДТП, поломки, повреждения).

Поля:
┌────────────────────┬──────────────────┬─────────────────────────────────┐
│ Поле               │ Тип              │ Описание                        │
├────────────────────┼──────────────────┼─────────────────────────────────┤
│ id                 │ Integer          │ PK, автоинкремент               │
│ booking_id         │ Integer          │ FK -> bookings.id (индекс)      │
│ vehicle_id         │ Integer          │ FK -> vehicles.id (индекс)      │
│ user_id            │ Integer          │ FK -> users.id (индекс)         │
│ incident_type      │ String(50)       │ Тип инцидента (индекс)          │
│ description        │ String           │ Описание                        │
│ status             │ String(30)       │ Статус (индекс, default='reported') │
└────────────────────┴──────────────────┴─────────────────────────────────┘

Связи:
- MANY-TO-ONE с bookings (много инцидентов - одно бронирование)
- MANY-TO-ONE с vehicles (много инцидентов - одно авто)
- MANY-TO-ONE с users (много инцидентов - один пользователь)

Составные индексы:
- INDEX(status, incident_type) - для фильтрации
- INDEX(vehicle_id, status) - инциденты по авто

ТИП СВЯЗИ: MANY-TO-ONE (N:1)
Реализация: Три внешних ключа - booking_id, vehicle_id, user_id

Типы инцидентов:
- accident - ДТП
- damage - повреждение
- breakdown - поломка
- theft - кража
- other - другое

Статусы:
- reported - сообщено
- investigating - расследуется
- resolved - решено
- closed - закрыто

================================================================================
----- ДИАГРАММА СВЯЗЕЙ МЕЖДУ ТАБЛИЦАМИ -----
================================================================================

Легенда:
  1 ---< N   = ONE-TO-MANY (одна запись связана со многими)
  N >--- 1   = MANY-TO-ONE (много записей связаны с одной)
  [FK]       = Foreign Key (внешний ключ)

┌─────────────┐
│   roles     │
│             │
│ id (PK)     │
│ name        │
└─────────────┘
       │ 1
       │
       │ <
       │ N
┌─────────────┐         ┌─────────────┐
│  branches   │         │  employees  │
│             │ 1    N  │             │
│ id (PK)     │<───────>│ id (PK)     │
│ name        │         │ email       │
│ address     │         │ role_id [FK]│
└─────────────┘         │ branch_id[FK]│
                        └─────────────┘


┌─────────────┐         ┌─────────────────────┐         ┌─────────────┐
│  tariffs    │         │      vehicles       │         │parking_zones│
│             │ 1    N  │                     │ N    1  │             │
│ id (PK)     │<───────>│ id (PK)             │>───────>│ id (PK)     │
│ name        │         │ license_plate       │         │ name        │
│price_per_min│         │ status              │         │ address     │
│price_per_hr │         │ tariff_id [FK]      │         │ capacity    │
└─────────────┘         │ parking_zone_id [FK]│         └─────────────┘
       │ 1              └─────────────────────┘
       │                        │ 1              │ 1
       │ <                      │ <              │ <
       │ N                      │ N              │ N
       │                ┌───────┴────────────────┴────────┐
       │                │                                  │
┌─────────────┐   ┌────────────────────┐                 │
│    users    │   │     bookings       │                 │
│             │ 1 │                    │                 │
│ id (PK)     │<──│ id (PK)            │                 │
│ email       │ N │ user_id [FK]       │                 │
│ phone       │   │ vehicle_id [FK]    │                 │
│ balance     │   │ tariff_id [FK]     │                 │
└─────────────┘   │ status             │                 │
       │ 1        └────────────────────┘                 │
       │ <               │ 1       │ 1                   │
       │ N               │ <       │ <                   │
       │                 │ N       │ N                   │
┌─────────────┐   ┌──────────┐  ┌──────────────┐        │
│transactions │   │incidents │  │  incidents   │        │
│             │   │          │  │  (booking)   │        │
│ id (PK)     │   │ id (PK)  │  │              │        │
│ user_id [FK]│   │ user_id[FK]│ │ booking_id[FK]       │
│booking_id[FK]│  │vehicle_id[FK]│ vehicle_id [FK]      │
│ type        │   │ type     │  │              │        │
└─────────────┘   └──────────┘  └──────────────┘        │
                        ^                                │
                        └────────────────────────────────┘

----- ТИПЫ СВЯЗЕЙ И ИХ РЕАЛИЗАЦИЯ -----

1. ONE-TO-MANY (1:N) - Основной тип связей в проекте

   Примеры:

   a) roles (1) -> employees (N)
      Реализация: таблица employees имеет поле role_id (FK -> roles.id)
      Смысл: Одна роль может быть у многих сотрудников

   b) branches (1) -> employees (N)
      Реализация: таблица employees имеет поле branch_id (FK -> branches.id)
      Смысл: В одном филиале работают много сотрудников

   c) users (1) -> bookings (N)
      Реализация: таблица bookings имеет поле user_id (FK -> users.id)
      Смысл: Один пользователь может иметь много бронирований

   d) vehicles (1) -> bookings (N)
      Реализация: таблица bookings имеет поле vehicle_id (FK -> vehicles.id)
      Смысл: Один автомобиль может быть забронирован много раз

   e) tariffs (1) -> vehicles (N)
      Реализация: таблица vehicles имеет поле tariff_id (FK -> tariffs.id)
      Смысл: Один тариф может применяться ко многим автомобилям

   f) parking_zones (1) -> vehicles (N)
      Реализация: таблица vehicles имеет поле parking_zone_id (FK -> parking_zones.id)
      Смысл: В одной парковочной зоне может быть много автомобилей

2. MANY-TO-ONE (N:1) - Обратная сторона ONE-TO-MANY

   Те же примеры с другой стороны:
   - Много бронирований принадлежат одному пользователю
   - Много сотрудников работают в одном филиале
   - И т.д.

3. СЛОЖНЫЕ СВЯЗИ - таблица как связующее звено

   bookings - центральная таблица, связывающая:
   - users (пользователи)
   - vehicles (автомобили)
   - tariffs (тарифы)

   Это паттерн "Association Table" (ассоциативная таблица)

4. КАСКАДНЫЕ СВЯЗИ

   При удалении родительской записи дочерние могут:
   - CASCADE - удалиться автоматически
   - SET NULL - обнулить FK
   - RESTRICT - запретить удаление

   В нашем проекте используется RESTRICT для сохранения истории.

----- ИНДЕКСЫ ДЛЯ ОПТИМИЗАЦИИ -----

1. Первичные ключи (PRIMARY KEY):
   - Автоматически индексируются
   - Быстрый поиск по ID

2. Уникальные индексы (UNIQUE):
   - users.email, users.phone - быстрая проверка уникальности при регистрации
   - vehicles.license_plate - поиск авто по номеру

3. Обычные индексы (INDEX):
   - employees.role_id, employees.branch_id - фильтрация сотрудников
   - bookings.user_id - быстрый поиск бронирований пользователя
   - vehicles.status - фильтр доступных авто

4. Составные индексы (COMPOSITE INDEX):
   - (vehicles.status, vehicles.vehicle_type) - фильтр "доступные седаны"
   - (bookings.user_id, bookings.status) - "активные бронирования пользователя"
   - (incidents.status, incidents.incident_type) - фильтр инцидентов

   ЗАЧЕМ СОСТАВНЫЕ ИНДЕКСЫ?
   - Оптимизация запросов с несколькими условиями WHERE
   - Ускорение популярных фильтров в UI
   - Без них такие запросы были бы медленными

================================================================================
5. РЕАЛИЗАЦИЯ В ПРИЛОЖЕНИИ
================================================================================

----- КАК ТАБЛИЦЫ РЕАЛИЗОВАНЫ В КОДЕ -----

1. SQLALCHEMY ORM МОДЕЛИ (back/db/models.py)

   ORM (Object-Relational Mapping) позволяет работать с БД как с Python объектами.

   Пример модели User:

   ```python
   class User(Base):
       __tablename__ = 'users'

       # Поля таблицы
       id = Column(Integer, primary_key=True, index=True)
       first_name = Column(String(50), nullable=False)
       last_name = Column(String(50), nullable=False)
       email = Column(String(100), unique=True, nullable=False, index=True)
       phone = Column(String(20), unique=True, nullable=False, index=True)
       password = Column(String(100), nullable=False)
       drivers_license = Column(String(20), unique=True)
       balance = Column(Float, default=0.0)

       # Связи с другими таблицами
       bookings = relationship('Booking', back_populates='user')
       transactions = relationship('Transaction', back_populates='user')
       incidents = relationship('Incident', back_populates='user')
   ```

   ЧТО ЭТО ДАЕТ:
   - Автоматическое создание таблицы в БД
   - Валидация типов данных
   - Удобная работа со связями
   - Защита от SQL-инъекций

   ПРИМЕР ИСПОЛЬЗОВАНИЯ:
   ```python
   # Создание пользователя
   user = User(
       first_name="Иван",
       email="ivan@example.com",
       balance=1000.0
   )
   db.add(user)
   db.commit()

   # Получение всех бронирований пользователя
   bookings = user.bookings  # Автоматически загружает связанные записи
   ```

2. PYDANTIC СХЕМЫ (back/schemas/*.py)

   Pydantic схемы для валидации входящих/исходящих данных API.

   Пример схемы для создания пользователя:

   ```python
   class UserCreate(BaseModel):
       first_name: str
       last_name: str
       email: EmailStr  # Автоматическая валидация email
       phone: str
       password: str
       drivers_license: Optional[str] = None
   ```

   ЗАЧЕМ ЭТО НУЖНО:
   - Валидация данных от клиента
   - Автоматическая генерация документации API
   - Сериализация/десериализация JSON
   - Преобразование типов

3. FASTAPI РОУТЕРЫ (back/routers/*.py)

   API endpoints для работы с данными.

   Пример эндпоинта для регистрации:

   ```python
   @router.post("/register", response_model=UserResponse)
   def register(user: UserCreate, db: Session = Depends(get_db)):
       # Проверка уникальности email
       existing = db.query(User).filter(User.email == user.email).first()
       if existing:
           raise HTTPException(status_code=400, detail="Email уже используется")

       # Создание пользователя
       db_user = User(**user.dict())
       db.add(db_user)
       db.commit()
       db.refresh(db_user)

       return db_user
   ```

   ЭТАПЫ ОБРАБОТКИ ЗАПРОСА:
   1. FastAPI получает POST /register
   2. Pydantic валидирует тело запроса (UserCreate)
   3. Функция обрабатывает логику (проверки, создание)
   4. SQLAlchemy сохраняет в БД
   5. Pydantic сериализует ответ (UserResponse)
   6. FastAPI возвращает JSON клиенту

----- РАБОТА СО СВЯЗЯМИ -----

1. LAZY LOADING (Ленивая загрузка)

   ```python
   # Получаем пользователя
   user = db.query(User).filter(User.id == 1).first()

   # При обращении к user.bookings SQLAlchemy автоматически
   # загрузит бронирования из БД
   bookings = user.bookings  # Дополнительный запрос к БД
   ```

2. EAGER LOADING (Жадная загрузка)

   ```python
   # Загружаем пользователя ВМЕСТЕ с бронированиями
   user = db.query(User).options(
       joinedload(User.bookings)
   ).filter(User.id == 1).first()

   # Теперь user.bookings уже загружены, нет дополнительных запросов
   bookings = user.bookings  # Мгновенно, без запроса к БД
   ```

   ПРЕИМУЩЕСТВО: Решает проблему N+1 запросов

3. СОЗДАНИЕ СВЯЗАННЫХ ОБЪЕКТОВ

   Пример: создание бронирования

   ```python
   # Создаем бронирование
   booking = Booking(
       user_id=1,              # Связь с пользователем
       vehicle_id=5,           # Связь с автомобилем
       tariff_id=2,            # Связь с тарифом
       start_time=datetime.now(),
       status='active'
   )
   db.add(booking)

   # Обновляем статус автомобиля
   vehicle = db.query(Vehicle).filter(Vehicle.id == 5).first()
   vehicle.status = 'in_use'

   db.commit()  # Одна транзакция для обоих изменений
   ```

4. КАСКАДНЫЕ ОПЕРАЦИИ

   ```python
   # При удалении пользователя его бронирования остаются
   # (для истории), но можно настроить каскадное удаление:

   bookings = relationship('Booking', back_populates='user',
                          cascade='all, delete-orphan')
   ```

----- FRONTEND: РАБОТА С API -----

1. API SERVICE (front/src/services/api.ts)

   ```typescript
   // Типизированный API клиент
   export const bookingService = {
     async createBooking(data: CreateBookingDto) {
       const response = await axios.post<Booking>(
         '/bookings',
         data
       );
       return response.data;
     },

     async getMyBookings() {
       const response = await axios.get<Booking[]>('/bookings/me');
       return response.data;
     }
   };
   ```

2. REDUX STORE (front/src/store/...)

   Централизованное управление состоянием приложения:

   ```typescript
   // Slice для бронирований
   const bookingsSlice = createSlice({
     name: 'bookings',
     initialState: {
       items: [],
       loading: false,
       error: null
     },
     reducers: {
       // Синхронные действия
     },
     extraReducers: (builder) => {
       // Асинхронные действия (API запросы)
       builder.addCase(fetchBookings.pending, (state) => {
         state.loading = true;
       });
       builder.addCase(fetchBookings.fulfilled, (state, action) => {
         state.items = action.payload;
         state.loading = false;
       });
     }
   });
   ```

3. REACT КОМПОНЕНТЫ

   ```typescript
   function BookingsList() {
     const dispatch = useDispatch();
     const bookings = useSelector(state => state.bookings.items);

     useEffect(() => {
       // Загружаем бронирования при монтировании компонента
       dispatch(fetchBookings());
     }, []);

     return (
       <div>
         {bookings.map(booking => (
           <BookingCard key={booking.id} booking={booking} />
         ))}
       </div>
     );
   }
   ```

----- БИЗНЕС-ЛОГИКА: ПРИМЕРЫ -----

1. СОЗДАНИЕ БРОНИРОВАНИЯ

   Последовательность операций:

   a) Клиент отправляет запрос:
      POST /bookings
      {
        "vehicle_id": 5,
        "start_time": "2025-11-05T14:00:00"
      }

   b) Backend валидирует данные (Pydantic)

   c) Проверка доступности авто:
      - Статус должен быть 'available'
      - Нет активных бронирований на это время

   d) Расчет стоимости на основе тарифа

   e) Создание записи в таблице bookings

   f) Обновление статуса авто на 'in_use'

   g) Возврат данных о бронировании клиенту

2. ЗАВЕРШЕНИЕ ПОЕЗДКИ

   a) Клиент нажимает "Завершить поездку"

   b) Backend получает booking_id

   c) Обновление бронирования:
      - end_time = текущее время
      - duration_hours = (end_time - start_time) / 3600
      - total_cost = расчет по тарифу
      - status = 'completed'

   d) Создание транзакции payment:
      - amount = total_cost
      - user_id из booking
      - transaction_type = 'payment'

   e) Списание с баланса пользователя:
      user.balance -= total_cost

   f) Возврат авто в статус 'available'

   g) Отправка данных клиенту

3. ФИЛЬТРАЦИЯ АВТОМОБИЛЕЙ

   Клиент может фильтровать авто по:
   - Статусу (доступен/занят)
   - Типу (седан/внедорожник/хэтчбек)
   - Марке
   - Тарифу
   - Парковочной зоне

   SQL запрос (через SQLAlchemy):
   ```python
   query = db.query(Vehicle)

   if status:
       query = query.filter(Vehicle.status == status)
   if vehicle_type:
       query = query.filter(Vehicle.vehicle_type == vehicle_type)
   if brand:
       query = query.filter(Vehicle.brand == brand)

   vehicles = query.all()
   ```

   Благодаря индексам этот запрос работает быстро даже на больших данных.

================================================================================
6. API ENDPOINTS
================================================================================

----- КЛИЕНТСКИЕ ЭНДПОИНТЫ -----

АВТОРИЗАЦИЯ (routers/auth.py):
  POST   /register          - Регистрация нового пользователя
  POST   /login             - Вход в систему
  GET    /me                - Получить текущего пользователя

ПРОФИЛЬ (routers/profile.py):
  GET    /profile           - Получить профиль
  PUT    /profile           - Обновить профиль
  POST   /profile/deposit   - Пополнить баланс

АВТОМОБИЛИ (routers/vehicles.py):
  GET    /vehicles          - Список всех авто (с фильтрами)
  GET    /vehicles/{id}     - Детали автомобиля

БРОНИРОВАНИЯ (routers/bookings.py):
  POST   /bookings          - Создать бронирование
  GET    /bookings/me       - Мои бронирования
  GET    /bookings/{id}     - Детали бронирования
  PUT    /bookings/{id}/start   - Начать поездку
  PUT    /bookings/{id}/end     - Завершить поездку
  DELETE /bookings/{id}     - Отменить бронирование

ТРАНЗАКЦИИ (routers/transactions.py):
  GET    /transactions/me   - История транзакций

ТАРИФЫ (routers/tariffs.py):
  GET    /tariffs           - Список всех тарифов

ПАРКОВКИ (routers/parking_zones.py):
  GET    /parking-zones     - Список парковочных зон

----- АДМИНСКИЕ ЭНДПОИНТЫ -----

АВТОРИЗАЦИЯ СОТРУДНИКОВ (routers/employee_auth.py):
  POST   /admin/auth/login  - Вход для сотрудников

УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЯМИ (routers/admin_users.py):
  GET    /admin/users       - Список всех пользователей
  GET    /admin/users/{id}  - Детали пользователя
  PUT    /admin/users/{id}  - Обновить пользователя
  DELETE /admin/users/{id}  - Удалить пользователя

УПРАВЛЕНИЕ АВТОМОБИЛЯМИ (routers/admin_vehicles.py):
  POST   /admin/vehicles    - Добавить автомобиль
  PUT    /admin/vehicles/{id} - Обновить автомобиль
  DELETE /admin/vehicles/{id} - Удалить автомобиль

УПРАВЛЕНИЕ БРОНИРОВАНИЯМИ (routers/admin_bookings.py):
  GET    /admin/bookings    - Все бронирования
  PUT    /admin/bookings/{id} - Обновить бронирование

ИНЦИДЕНТЫ (routers/admin_incidents.py):
  GET    /admin/incidents   - Список инцидентов
  POST   /admin/incidents   - Создать инцидент
  PUT    /admin/incidents/{id} - Обновить статус инцидента

СОТРУДНИКИ (routers/admin_employees.py):
  GET    /admin/employees   - Список сотрудников
  POST   /admin/employees   - Добавить сотрудника
  PUT    /admin/employees/{id} - Обновить сотрудника
  DELETE /admin/employees/{id} - Удалить сотрудника

ТАРИФЫ (routers/admin_tariffs.py):
  POST   /admin/tariffs     - Создать тариф
  PUT    /admin/tariffs/{id} - Обновить тариф
  DELETE /admin/tariffs/{id} - Удалить тариф

ПАРКОВКИ (routers/admin_parking.py):
  POST   /admin/parking-zones     - Создать парковку
  PUT    /admin/parking-zones/{id} - Обновить парковку
  DELETE /admin/parking-zones/{id} - Удалить парковку

ФИЛИАЛЫ (routers/admin_branches.py):
  GET    /admin/branches    - Список филиалов
  POST   /admin/branches    - Создать филиал
  PUT    /admin/branches/{id} - Обновить филиал
  DELETE /admin/branches/{id} - Удалить филиал

СТАТИСТИКА (routers/admin_stats.py):
  GET    /admin/stats       - Общая статистика системы

----- АВТОМАТИЧЕСКАЯ ДОКУМЕНТАЦИЯ -----

FastAPI автоматически генерирует интерактивную документацию:

  GET    /docs              - Swagger UI (интерактивная документация)
  GET    /redoc             - ReDoc (альтернативная документация)

В Swagger UI можно:
- Увидеть все эндпоинты
- Посмотреть схемы запросов/ответов
- Протестировать API прямо в браузере
- Увидеть коды ответов и ошибки

================================================================================
7. ЗАКЛЮЧЕНИЕ
================================================================================

----- ДОСТИЖЕНИЯ ПРОЕКТА -----

1. ПОЛНОФУНКЦИОНАЛЬНАЯ СИСТЕМА:
   - Регистрация и авторизация двух типов пользователей
   - Каталог автомобилей с расширенной фильтрацией
   - Система бронирований с расчетом стоимости
   - Финансовые транзакции и управление балансом
   - Отчеты об инцидентах
   - Административная панель
   - Статистика и аналитика

2. СОВРЕМЕННЫЙ ТЕХНОЛОГИЧЕСКИЙ СТЕК:
   - Backend: Python 3.12 + FastAPI + SQLAlchemy + PostgreSQL
   - Frontend: React 18 + TypeScript + Redux Toolkit + TailwindCSS
   - Автоматическая документация API
   - Типобезопасность на обеих сторонах

3. КАЧЕСТВЕННАЯ АРХИТЕКТУРА БД:
   - 10 нормализованных таблиц
   - Правильные связи (ONE-TO-MANY, MANY-TO-ONE)
   - Оптимизация через индексы (простые и составные)
   - Целостность данных через Foreign Keys
   - Масштабируемость

4. BEST PRACTICES:
   - Разделение на слои (Layered Architecture)
   - REST API принципы
   - Валидация данных
   - Обработка ошибок
   - Компонентный подход на фронтенде
   - Централизованное управление состоянием

----- ВОЗМОЖНОСТИ ДЛЯ РАСШИРЕНИЯ -----

1. Интеграция платежных систем (Stripe, PayPal)
2. Геолокация автомобилей (GPS)
3. Мобильное приложение (React Native)
4. Система отзывов и рейтингов
5. Push-уведомления
6. Интеграция с картами (Yandex Maps, Google Maps)
7. Система лояльности и промокодов
8. Чат поддержки
9. Аналитика и отчеты (charts, dashboards)
10. Микросервисная архитектура при росте нагрузки

----- ПРАКТИЧЕСКАЯ ПОЛЬЗА ПРОЕКТА -----

1. ОБУЧЕНИЕ:
   - Демонстрация знаний современных технологий
   - Понимание баз данных и связей
   - Опыт разработки fullstack приложения
   - Работа с REST API

2. ПОРТФОЛИО:
   - Готовый проект для резюме
   - Демонстрация навыков работодателю
   - База для более сложных проектов

3. РЕАЛЬНАЯ ПРИМЕНИМОСТЬ:
   - Может быть использован как база для реального стартапа
   - Легко адаптируется для других отраслей (аренда велосипедов, самокатов)
   - Готов к деплою на production

----- ЗАКЛЮЧИТЕЛЬНЫЕ СЛОВА -----

CarShareX - это комплексный учебный проект, демонстрирующий современные
подходы к разработке веб-приложений. Проект включает все ключевые компоненты
коммерческих систем: регистрацию пользователей, управление каталогом,
бронирования, финансовые транзакции, административную панель.

Использование актуального технологического стека (Python + FastAPI + React +
TypeScript) и правильная архитектура базы данных с оптимизацией через индексы
делают этот проект отличным примером для защиты курсовой работы или диплома.

Проект готов к демонстрации, легко расширяется и может служить основой для
реального коммерческого продукта.

================================================================================
                             КОНЕЦ ДОКУМЕНТА
================================================================================

Автор: Студент группы [УКАЖИТЕ ВАШУ ГРУППУ]
Дата: Ноябрь 2025
Проект: CarShareX - Каршеринг-приложение

Контакты для вопросов:
Email: [ВАШ EMAIL]
GitHub: https://github.com/peklos/CarShareX

Спасибо за внимание!
